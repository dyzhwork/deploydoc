(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{455:function(a,t,s){"use strict";s.r(t);var e=s(7),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"es2018-es9-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es2018-es9-新特性"}},[a._v("#")]),a._v(" ES2018（ES9）新特性")]),a._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[a._v("点击查看")]),a._v(" "),t("ul",[t("li",[a._v("异步迭代：async、await。")]),a._v(" "),t("li",[a._v("Promise 方法：：finally()。无论结果是 Resolved 或者是 Rejected 都会执行。")]),a._v(" "),t("li",[a._v("Rest、Spread 操作符和对象构建。")]),a._v(" "),t("li",[a._v("正则表达式：命名捕获组、反向断言、Unicode 属性转义。")]),a._v(" "),t("li",[a._v("模板文字和带标签的模板文字。")])])]),a._v(" "),t("h2",{attrs:{id:"异步迭代-async、await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步迭代-async、await"}},[a._v("#")]),a._v(" 异步迭代：async、await")]),a._v(" "),t("p",[a._v("在异步/等待过程中的某个时刻，您将尝试在同步循环内调用异步函数。")]),a._v(" "),t("h2",{attrs:{id:"promise-finally"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-finally"}},[a._v("#")]),a._v(" Promise.finally()")]),a._v(" "),t("p",[a._v("在之前的 Promise 的调用链要么调用成功返回.then()方法，要么调用失败返回.catch()方法。在某些情况下，你想要在无论是成功还是失败，都运行同样的代码。例如实现清除、删除对话、关闭数据连接等操作。Promise.finally()允许你指定最终的逻辑。这为指定执行完 Promise 后，无论结果是 Resolved 或者是 Rejected 都需要执行的代码提供了一种方式。")]),a._v(" "),t("p",[a._v("Promise.finally()法接受一个回调函数作为参数，由于无法知道 Promise 实例的最终状态，所以 finally()的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。")]),a._v(" "),t("h2",{attrs:{id:"rest-spread-操作符和对象构建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rest-spread-操作符和对象构建"}},[a._v("#")]),a._v(" Rest/Spread 操作符和对象构建")]),a._v(" "),t("p",[a._v("Rest 和 Spread 的操作符都是...，只不过使用的场景和目的不一样。Rest（展开）主要用在对象的解构，目前只支持对象的解构和不确定的参数描述。Spread（扩展）主要用在字面量对象的构建上。")]),a._v(" "),t("h2",{attrs:{id:"正则表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[a._v("#")]),a._v(" 正则表达式")]),a._v(" "),t("p",[a._v("命名捕获组\nJavaScript 正则表达式可以返回匹配对象-类似于数组的值，包含匹配的字符串。例如，要以 YYYY-MM-DD 格式解析日期：")]),a._v(" "),t("h2",{attrs:{id:"反向断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反向断言"}},[a._v("#")]),a._v(" 反向断言")]),a._v(" "),t("p",[a._v("JavaScript 目前支持正则表达式中的前瞻断言。这意味着必须进行匹配但不捕获任何内容，并且断言不包含在整个匹配的字符串中。例如，要从任何价格中捕获货币符号：")]),a._v(" "),t("h2",{attrs:{id:"dotall-模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dotall-模式"}},[a._v("#")]),a._v(" dotAll 模式")]),a._v(" "),t("p",[a._v("正则表达式中.（点）匹配除回车外的任何单字符，标记 s 改变这种行为，允许行终止符的出现，例如：")]),a._v(" "),t("h2",{attrs:{id:"unicode-属性转义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#unicode-属性转义"}},[a._v("#")]),a._v(" Unicode 属性转义")]),a._v(" "),t("p",[a._v("到目前为止，还无法在正则表达式中本机访问 Unicode 字符属性。ES2018 在设置了 u（Unicode）标志的正则表达式中，以\\p｛…｝和\\p｛…}的形式，添加 Unicode 属性转义。")]),a._v(" "),t("h2",{attrs:{id:"模板文字调整"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板文字调整"}},[a._v("#")]),a._v(" 模板文字调整")]),a._v(" "),t("p",[a._v("之前，\\u 开始一个 unicode 转义，\\x 开始一个十六进制转义，\\后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如 Windows 文件路径 C:\\uuu\\xxx\\111")]),a._v(" "),t("p",[a._v("ES2018 删除了与模板文字中的转义序列相关的所有语法限制。")])])}),[],!1,null,null,null);t.default=r.exports}}]);